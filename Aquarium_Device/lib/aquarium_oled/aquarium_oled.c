/**
 * @file aquarium_oled.c
 * @brief SSD1306 OLED 驱动实现
 */

#include "aquarium_oled.h"
#include <string.h>

#define OLED_CTRL_CMD 0x00
#define OLED_CTRL_DATA 0x40

static const uint8_t g_init_cmds[] = {0xAE, 0xD5, 0x80, 0xA8, 0x3F, 0xD3, 0x00,
                                      0x40, 0x8D, 0x14, 0x20, 0x00, 0xA1, 0xC8,
                                      0xDA, 0x12, 0x81, 0xCF, 0xD9, 0xF1, 0xDB,
                                      0x40, 0xA4, 0xA6, 0xAF};

/* 5x7 字体 ASCII 32~90 */
static const uint8_t g_font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x5F, 0x00, 0x00},
    {0x00, 0x07, 0x00, 0x07, 0x00}, {0x14, 0x7F, 0x14, 0x7F, 0x14},
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, {0x23, 0x13, 0x08, 0x64, 0x62},
    {0x36, 0x49, 0x55, 0x22, 0x50}, {0x00, 0x05, 0x03, 0x00, 0x00},
    {0x00, 0x1C, 0x22, 0x41, 0x00}, {0x00, 0x41, 0x22, 0x1C, 0x00},
    {0x14, 0x08, 0x3E, 0x08, 0x14}, {0x08, 0x08, 0x3E, 0x08, 0x08},
    {0x00, 0x50, 0x30, 0x00, 0x00}, {0x08, 0x08, 0x08, 0x08, 0x08},
    {0x00, 0x60, 0x60, 0x00, 0x00}, {0x20, 0x10, 0x08, 0x04, 0x02},
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, {0x00, 0x42, 0x7F, 0x40, 0x00},
    {0x42, 0x61, 0x51, 0x49, 0x46}, {0x21, 0x41, 0x45, 0x4B, 0x31},
    {0x18, 0x14, 0x12, 0x7F, 0x10}, {0x27, 0x45, 0x45, 0x45, 0x39},
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, {0x01, 0x71, 0x09, 0x05, 0x03},
    {0x36, 0x49, 0x49, 0x49, 0x36}, {0x06, 0x49, 0x49, 0x29, 0x1E},
    {0x00, 0x36, 0x36, 0x00, 0x00}, {0x00, 0x56, 0x36, 0x00, 0x00},
    {0x08, 0x14, 0x22, 0x41, 0x00}, {0x14, 0x14, 0x14, 0x14, 0x14},
    {0x00, 0x41, 0x22, 0x14, 0x08}, {0x02, 0x01, 0x51, 0x09, 0x06},
    {0x32, 0x49, 0x79, 0x41, 0x3E}, {0x7E, 0x11, 0x11, 0x11, 0x7E},
    {0x7F, 0x49, 0x49, 0x49, 0x36}, {0x3E, 0x41, 0x41, 0x41, 0x22},
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, {0x7F, 0x49, 0x49, 0x49, 0x41},
    {0x7F, 0x09, 0x09, 0x09, 0x01}, {0x3E, 0x41, 0x49, 0x49, 0x7A},
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, {0x00, 0x41, 0x7F, 0x41, 0x00},
    {0x20, 0x40, 0x41, 0x3F, 0x01}, {0x7F, 0x08, 0x14, 0x22, 0x41},
    {0x7F, 0x40, 0x40, 0x40, 0x40}, {0x7F, 0x02, 0x0C, 0x02, 0x7F},
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, {0x3E, 0x41, 0x41, 0x41, 0x3E},
    {0x7F, 0x09, 0x09, 0x09, 0x06}, {0x3E, 0x41, 0x51, 0x21, 0x5E},
    {0x7F, 0x09, 0x19, 0x29, 0x46}, {0x46, 0x49, 0x49, 0x49, 0x31},
    {0x01, 0x01, 0x7F, 0x01, 0x01}, {0x3F, 0x40, 0x40, 0x40, 0x3F},
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, {0x3F, 0x40, 0x38, 0x40, 0x3F},
    {0x63, 0x14, 0x08, 0x14, 0x63}, {0x07, 0x08, 0x70, 0x08, 0x07},
    {0x61, 0x51, 0x49, 0x45, 0x43},
};

#define FONT_CHAR_COUNT 59

static void send_cmd(OledContext *ctx, uint8_t cmd) {
  uint8_t buf[2] = {OLED_CTRL_CMD, cmd};
  if (ctx->hw && ctx->hw->i2c_write) {
    ctx->hw->i2c_write(ctx->i2c_addr, buf, 2);
  }
}

void oled_init(OledContext *ctx, const OledHwOps *hw, uint8_t i2c_addr) {
  ctx->hw = hw;
  ctx->i2c_addr = i2c_addr;
  memset(ctx->buffer, 0, OLED_BUF_SIZE);
  for (uint8_t i = 0; i < sizeof(g_init_cmds); i++) {
    send_cmd(ctx, g_init_cmds[i]);
  }
}

void oled_clear(OledContext *ctx) { memset(ctx->buffer, 0, OLED_BUF_SIZE); }

void oled_set_pixel(OledContext *ctx, uint8_t x, uint8_t y, bool on) {
  if (x >= OLED_WIDTH || y >= OLED_HEIGHT)
    return;
  uint16_t idx = x + (y / 8) * OLED_WIDTH;
  if (on)
    ctx->buffer[idx] |= (1 << (y % 8));
  else
    ctx->buffer[idx] &= ~(1 << (y % 8));
}

void oled_draw_char(OledContext *ctx, uint8_t x, uint8_t y, char c) {
  if (c < 32 || c > 90)
    c = ' ';
  uint8_t idx = (uint8_t)(c - 32);
  if (idx >= FONT_CHAR_COUNT)
    idx = 0;
  for (uint8_t col = 0; col < 5; col++) {
    uint8_t line = g_font5x7[idx][col];
    for (uint8_t row = 0; row < 7; row++) {
      oled_set_pixel(ctx, x + col, y + row, (line >> row) & 1);
    }
  }
}

void oled_draw_string(OledContext *ctx, uint8_t x, uint8_t y, const char *s) {
  while (*s && x < OLED_WIDTH - 5) {
    oled_draw_char(ctx, x, y, *s++);
    x += 6;
  }
}

void oled_render(OledContext *ctx) {
  if (!ctx->hw || !ctx->hw->i2c_write)
    return;
  send_cmd(ctx, 0x21);
  send_cmd(ctx, 0);
  send_cmd(ctx, 127);
  send_cmd(ctx, 0x22);
  send_cmd(ctx, 0);
  send_cmd(ctx, 7);
  uint8_t buf[17];
  buf[0] = OLED_CTRL_DATA;
  for (uint8_t page = 0; page < OLED_PAGES; page++) {
    for (uint8_t seg = 0; seg < OLED_WIDTH; seg += 16) {
      memcpy(&buf[1], &ctx->buffer[page * OLED_WIDTH + seg], 16);
      ctx->hw->i2c_write(ctx->i2c_addr, buf, 17);
    }
  }
}
